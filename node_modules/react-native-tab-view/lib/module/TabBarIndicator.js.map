{"version":3,"sources":["TabBarIndicator.tsx"],"names":["React","StyleSheet","I18nManager","Animated","Easing","memoize","interpolate","multiply","Extrapolate","TabBarIndicator","fadeInIndicator","props","navigationState","layout","width","getTabWidth","isIndicatorShown","routes","every","_","i","timing","opacity","duration","toValue","easing","in","linear","start","Value","getTranslateX","position","inputRange","map","outputRange","reduce","acc","translateX","extrapolate","CLAMP","isRTL","getWidth","style","length","indicatorWidth","styles","indicator","transform","left","index","Component","create","backgroundColor","bottom","right","height"],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport { StyleSheet, I18nManager, StyleProp, ViewStyle } from 'react-native';\nimport Animated, { Easing } from 'react-native-reanimated';\n\nimport memoize from './memoize';\nimport { Route, SceneRendererProps, NavigationState } from './types';\n\nexport type GetTabWidth = (index: number) => number;\n\nexport type Props<T extends Route> = SceneRendererProps & {\n  navigationState: NavigationState<T>;\n  width: string;\n  style?: StyleProp<ViewStyle>;\n  getTabWidth: GetTabWidth;\n};\n\nconst { interpolate, multiply, Extrapolate } = Animated;\n\nexport default class TabBarIndicator<T extends Route> extends React.Component<\n  Props<T>\n> {\n  componentDidMount() {\n    this.fadeInIndicator();\n  }\n\n  componentDidUpdate() {\n    this.fadeInIndicator();\n  }\n\n  private fadeInIndicator = () => {\n    const { navigationState, layout, width, getTabWidth } = this.props;\n\n    if (\n      !this.isIndicatorShown &&\n      width === 'auto' &&\n      layout.width &&\n      // We should fade-in the indicator when we have widths for all the tab items\n      navigationState.routes.every((_, i) => getTabWidth(i))\n    ) {\n      this.isIndicatorShown = true;\n\n      Animated.timing(this.opacity, {\n        duration: 150,\n        toValue: 1,\n        easing: Easing.in(Easing.linear),\n      }).start();\n    }\n  };\n\n  private isIndicatorShown = false;\n\n  private opacity = new Animated.Value(this.props.width === 'auto' ? 0 : 1);\n\n  private getTranslateX = memoize(\n    (\n      position: Animated.Node<number>,\n      routes: Route[],\n      getTabWidth: GetTabWidth\n    ) => {\n      const inputRange = routes.map((_, i) => i);\n\n      // every index contains widths at all previous indices\n      const outputRange = routes.reduce<number[]>((acc, _, i) => {\n        if (i === 0) return [0];\n        return [...acc, acc[i - 1] + getTabWidth(i - 1)];\n      }, []);\n\n      const translateX = interpolate(position, {\n        inputRange,\n        outputRange,\n        extrapolate: Extrapolate.CLAMP,\n      });\n\n      return multiply(translateX, I18nManager.isRTL ? -1 : 1);\n    }\n  );\n\n  private getWidth = memoize(\n    (\n      position: Animated.Node<number>,\n      routes: Route[],\n      getTabWidth: GetTabWidth\n    ) => {\n      const inputRange = routes.map((_, i) => i);\n      const outputRange = inputRange.map(getTabWidth);\n\n      return interpolate(position, {\n        inputRange,\n        outputRange,\n        extrapolate: Extrapolate.CLAMP,\n      });\n    }\n  );\n\n  render() {\n    const {\n      position,\n      navigationState,\n      getTabWidth,\n      width,\n      style,\n      layout,\n    } = this.props;\n    const { routes } = navigationState;\n\n    const translateX =\n      routes.length > 1 ? this.getTranslateX(position, routes, getTabWidth) : 0;\n\n    const indicatorWidth =\n      width === 'auto'\n        ? routes.length > 1\n          ? this.getWidth(position, routes, getTabWidth)\n          : getTabWidth(0)\n        : width;\n\n    return (\n      <Animated.View\n        style={[\n          styles.indicator,\n          // If layout is not available, use `left` property for positioning the indicator\n          // This avoids rendering delay until we are able to calculate translateX\n          { width: indicatorWidth },\n          layout.width\n            ? { transform: [{ translateX }] as any }\n            : { left: `${(100 / routes.length) * navigationState.index}%` },\n          width === 'auto' ? { opacity: this.opacity } : null,\n          style,\n        ]}\n      />\n    );\n  }\n}\n\nconst styles = StyleSheet.create({\n  indicator: {\n    backgroundColor: '#ffeb3b',\n    position: 'absolute',\n    left: 0,\n    bottom: 0,\n    right: 0,\n    height: 2,\n  },\n});\n"]}