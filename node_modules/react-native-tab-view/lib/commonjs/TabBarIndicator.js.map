{"version":3,"sources":["TabBarIndicator.tsx"],"names":["interpolate","Animated","multiply","Extrapolate","TabBarIndicator","fadeInIndicator","props","navigationState","layout","width","getTabWidth","isIndicatorShown","routes","every","_","i","timing","opacity","duration","toValue","easing","Easing","in","linear","start","Value","getTranslateX","position","inputRange","map","outputRange","reduce","acc","translateX","extrapolate","CLAMP","I18nManager","isRTL","getWidth","style","length","indicatorWidth","styles","indicator","transform","left","index","React","Component","StyleSheet","create","backgroundColor","bottom","right","height"],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport { StyleSheet, I18nManager, StyleProp, ViewStyle } from 'react-native';\nimport Animated, { Easing } from 'react-native-reanimated';\n\nimport memoize from './memoize';\nimport { Route, SceneRendererProps, NavigationState } from './types';\n\nexport type GetTabWidth = (index: number) => number;\n\nexport type Props<T extends Route> = SceneRendererProps & {\n  navigationState: NavigationState<T>;\n  width: string;\n  style?: StyleProp<ViewStyle>;\n  getTabWidth: GetTabWidth;\n};\n\nconst { interpolate, multiply, Extrapolate } = Animated;\n\nexport default class TabBarIndicator<T extends Route> extends React.Component<\n  Props<T>\n> {\n  componentDidMount() {\n    this.fadeInIndicator();\n  }\n\n  componentDidUpdate() {\n    this.fadeInIndicator();\n  }\n\n  private fadeInIndicator = () => {\n    const { navigationState, layout, width, getTabWidth } = this.props;\n\n    if (\n      !this.isIndicatorShown &&\n      width === 'auto' &&\n      layout.width &&\n      // We should fade-in the indicator when we have widths for all the tab items\n      navigationState.routes.every((_, i) => getTabWidth(i))\n    ) {\n      this.isIndicatorShown = true;\n\n      Animated.timing(this.opacity, {\n        duration: 150,\n        toValue: 1,\n        easing: Easing.in(Easing.linear),\n      }).start();\n    }\n  };\n\n  private isIndicatorShown = false;\n\n  private opacity = new Animated.Value(this.props.width === 'auto' ? 0 : 1);\n\n  private getTranslateX = memoize(\n    (\n      position: Animated.Node<number>,\n      routes: Route[],\n      getTabWidth: GetTabWidth\n    ) => {\n      const inputRange = routes.map((_, i) => i);\n\n      // every index contains widths at all previous indices\n      const outputRange = routes.reduce<number[]>((acc, _, i) => {\n        if (i === 0) return [0];\n        return [...acc, acc[i - 1] + getTabWidth(i - 1)];\n      }, []);\n\n      const translateX = interpolate(position, {\n        inputRange,\n        outputRange,\n        extrapolate: Extrapolate.CLAMP,\n      });\n\n      return multiply(translateX, I18nManager.isRTL ? -1 : 1);\n    }\n  );\n\n  private getWidth = memoize(\n    (\n      position: Animated.Node<number>,\n      routes: Route[],\n      getTabWidth: GetTabWidth\n    ) => {\n      const inputRange = routes.map((_, i) => i);\n      const outputRange = inputRange.map(getTabWidth);\n\n      return interpolate(position, {\n        inputRange,\n        outputRange,\n        extrapolate: Extrapolate.CLAMP,\n      });\n    }\n  );\n\n  render() {\n    const {\n      position,\n      navigationState,\n      getTabWidth,\n      width,\n      style,\n      layout,\n    } = this.props;\n    const { routes } = navigationState;\n\n    const translateX =\n      routes.length > 1 ? this.getTranslateX(position, routes, getTabWidth) : 0;\n\n    const indicatorWidth =\n      width === 'auto'\n        ? routes.length > 1\n          ? this.getWidth(position, routes, getTabWidth)\n          : getTabWidth(0)\n        : width;\n\n    return (\n      <Animated.View\n        style={[\n          styles.indicator,\n          // If layout is not available, use `left` property for positioning the indicator\n          // This avoids rendering delay until we are able to calculate translateX\n          { width: indicatorWidth },\n          layout.width\n            ? { transform: [{ translateX }] as any }\n            : { left: `${(100 / routes.length) * navigationState.index}%` },\n          width === 'auto' ? { opacity: this.opacity } : null,\n          style,\n        ]}\n      />\n    );\n  }\n}\n\nconst styles = StyleSheet.create({\n  indicator: {\n    backgroundColor: '#ffeb3b',\n    position: 'absolute',\n    left: 0,\n    bottom: 0,\n    right: 0,\n    height: 2,\n  },\n});\n"]}